name: FKS Main Pipeline

on:
  push:
    branches: [main, develop]
    tags: ['v*']
    paths-ignore: ['docs/**', '*.md']
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened, labeled, unlabeled]
  issues:
    types: [opened, labeled, unlabeled, closed, reopened, assigned, unassigned]
  pull_request_target:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  schedule:
    - cron: '0 9 * * 1'  # Weekly Monday 9 AM UTC
  workflow_dispatch:
    inputs:
      python_version:
        description: 'Python version to test (3.10-3.13)'
        type: choice
        default: '3.13'
        options: ['3.10', '3.11', '3.12', '3.13']
      skip_tests:
        description: 'Skip test execution'
        type: boolean
        default: false
      environment:
        description: 'Target environment (staging/production)'
        type: choice
        default: 'staging'
        options: ['staging', 'production']
      commit_changes:
        description: 'Auto-commit PROJECT_STATUS.md updates'
        type: boolean
        default: true
      sync_existing:
        description: 'Sync all existing open issues/PRs to project'
        type: boolean
        default: false
      action:
        description: 'Manual action (sync-all-issues, update-project-status, cleanup-stale-items)'
        type: choice
        options: ['sync-all-issues', 'update-project-status', 'cleanup-stale-items']

permissions:
  contents: read
  issues: write
  pull-requests: write
  repository-projects: write
  actions: read
  checks: write
  deployments: write
  id-token: write
  security-events: write

env:
  PROJECT_NUMBER: 1  # Your project board number
  PYTHON_VERSION: ${{ inputs.python_version || '3.13' }}

jobs:
  notify-start:
    runs-on: self-hosted
    timeout-minutes: 5
    if: always() && (github.event_name != 'schedule')
    steps:
      - name: Send Discord Start Notification
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK }}
          title: "🚀 Pipeline Started"
          description: |
            **Event:** ${{ github.event_name }}
            **Repository:** ${{ github.repository }}
            **Branch/Ref:** ${{ github.ref_name }}
            **Actor:** ${{ github.actor }}
          color: 0x9C27B0
          username: FKS Bot

  label-pr:
    runs-on: self-hosted
    timeout-minutes: 5
    if: contains(fromJSON('["pull_request", "pull_request_target"]'), github.event_name)
    steps:
      - uses: actions/checkout@v4
      - name: Apply Labels
        uses: actions/labeler@v5
        with:
          configuration-path: .github/labeler.yml
          sync-labels: true

  test:
    runs-on: ubuntu-latest  # Use GitHub-hosted for Docker services
    timeout-minutes: 10  # Reduced from 15 - tests shouldn't take this long
    if: (!inputs.skip_tests) && (github.event_name == 'push' || github.event_name == 'pull_request' || github.event_name == 'pull_request_target' || github.event_name == 'workflow_dispatch')
    strategy:
      fail-fast: false  # Don't cancel all tests on first failure
      matrix:
        python-version: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', inputs.python_version)) || fromJSON('["3.10", "3.11", "3.12", "3.13"]') }}
    services:
      postgres:
        image: timescale/timescaledb:latest-pg16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd "redis-cli ping" --health-interval 10s --health-timeout 5s --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      - name: Install Deps
        run: pip install -r requirements.txt pytest pytest-cov
      - name: Run Tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb
        run: |
          # Run tests with timeout to prevent hanging
          timeout 480 pytest tests/ -v --cov=src --cov-report=json --cov-report=html --cov-report=term -x --tb=short || true
        continue-on-error: true  # Temporary: 20/34 tests fail due to legacy imports (Issue #75)
        timeout-minutes: 9  # Fail if tests hang
      - name: Report Test Results
        if: always()
        run: |
          if [ -f .coverage ]; then
            echo "✅ Tests completed (some failures expected until Issue #75 fixed)"
            echo "📊 See coverage reports in artifacts"
          else
            echo "⚠️  Tests failed to run - check configuration"
          fi
      - name: Upload Coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false
        continue-on-error: true  # Don't fail if Codecov token not configured
      - name: Coverage Comment
        uses: ewjoachim/python-coverage-comment-action@v3
        if: github.event_name == 'pull_request'
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true  # Don't fail if action has issues

  lint:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event_name == 'push' || github.event_name == 'pull_request' || github.event_name == 'pull_request_target' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-lint-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-lint-
      - name: Install Linters
        run: pip install ruff black isort mypy
      - name: Run Ruff Check
        run: |
          ruff check src/ --output-format=json > lint-report.json || echo "[]" > lint-report.json
          ruff check src/ --output-format=github || true
          echo "## 🔍 Ruff Lint Results" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ruff check src/ --statistics || echo "Issues found - see annotations above" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true  # Temporary: Allow lint warnings until Issue #76 (Code Cleanup)
      - name: Run Black Check
        run: |
          black --check src/ || true
          echo "## 🎨 Black Format Check" >> $GITHUB_STEP_SUMMARY
          black --check src/ --diff 2>&1 | head -20 >> $GITHUB_STEP_SUMMARY || echo "Formatting issues found" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true  # Temporary: Allow format issues until Issue #76
      - name: Run Isort Check
        run: |
          isort --check-only src/ || true
          echo "## 📦 Import Sort Check" >> $GITHUB_STEP_SUMMARY
          isort --check-only --diff src/ 2>&1 | head -20 >> $GITHUB_STEP_SUMMARY || echo "Import sorting needed" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true  # Temporary: Allow import order issues until Issue #76
      - name: Run Mypy
        run: mypy src/ --ignore-missing-imports --json-report mypy-report
        continue-on-error: true  # Type hints are warnings, not errors
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lint-reports-${{ github.run_number }}
          path: |
            lint-report.json
            mypy-report/

  security:
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Reduced from 10 - security scans should be fast
    if: github.event_name == 'push' || github.event_name == 'pull_request' || github.event_name == 'pull_request_target' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      - name: Install Security Tools
        run: pip install pip-audit bandit safety
        timeout-minutes: 2
      - name: Pip Audit
        run: |
          timeout 120 pip-audit --requirement requirements.txt --format json > security-audit.json || echo "[]" > security-audit.json
          pip-audit --requirement requirements.txt || true
        timeout-minutes: 2
        continue-on-error: true
      - name: Bandit Scan
        run: |
          timeout 60 bandit -r src/ -f json > bandit-report.json || echo "{}" > bandit-report.json
          bandit -r src/ || true
        timeout-minutes: 1
        continue-on-error: true
      - name: Safety Check
        run: |
          timeout 60 safety check --full-report > safety-report.txt || echo "Safety check completed with warnings" >> safety-report.txt
          safety check || true
        timeout-minutes: 1
        continue-on-error: true
      - name: Parse Security Results
        run: |
          echo "## Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "### Pip Audit" >> $GITHUB_STEP_SUMMARY
          cat security-audit.json >> $GITHUB_STEP_SUMMARY || true
          echo "### Bandit Scan" >> $GITHUB_STEP_SUMMARY
          cat bandit-report.json >> $GITHUB_STEP_SUMMARY || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.run_number }}
          path: |
            security-audit.json
            bandit-report.json
            safety-report.txt

  docker-build-push:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test, lint, security]
    if: |
      (github.event_name == 'push' && (github.ref_type == 'tag' || github.ref == 'refs/heads/main')) || 
      github.event_name == 'workflow_dispatch' &&
      (needs.test.result == 'success' || needs.test.result == 'failure') &&
      (needs.lint.result == 'success' || needs.lint.result == 'failure') &&
      needs.security.result != 'failure'
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_API_TOKEN }}
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.ref_type == 'tag' }}
      - name: Build and Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  release:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: docker-build-push
    if: github.ref_type == 'tag'
    steps:
      - uses: actions/checkout@v4
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ github.ref_name }}
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref_name, 'rc') || contains(github.ref_name, 'beta') }}

  dns-update:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: release
    if: inputs.environment && (inputs.environment == 'staging' || inputs.environment == 'production') && github.ref_type == 'tag'
    steps:
      - uses: actions/checkout@v4
      - name: Update Cloudflare DNS
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          # TODO: Implement actual DNS update logic
          # Example:
          # RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=${ENVIRONMENT}.fks.example.com" \
          #   -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" | jq -r '.result[0].id')
          # curl -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
          #   -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
          #   -H "Content-Type: application/json" \
          #   --data '{"type":"A","name":"'${ENVIRONMENT}'.fks.example.com","content":"NEW_IP","ttl":3600,"proxied":true}'
          echo "⚠️  DNS update not implemented yet - skipping"

  health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && (inputs.action == 'update-project-status' || contains(inputs.action, 'update-project-status')))
    services:
      postgres:
        image: timescale/timescaledb:latest-pg16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd "redis-cli ping" --health-interval 10s --health-timeout 5s --health-retries 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # For git history analysis
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      - name: Install Deps
        run: pip install -r requirements.txt pytest pytest-cov pip-audit ruff mypy black isort
      - name: Run Tests/Coverage
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb
        run: pytest tests/ -v --cov=src --cov-report=json --cov-report=term || true
        continue-on-error: true
      - name: Security Audit
        run: pip-audit --requirement requirements.txt --format json > security-audit.json || echo "[]" > security-audit.json
        continue-on-error: true
      - name: Lint
        run: ruff check src/ --output-format=json > lint-report.json || echo "[]" > lint-report.json
        continue-on-error: true
      - name: Type Check
        run: mypy src/ --ignore-missing-imports --json-report mypy-report || true
        continue-on-error: true
      - name: Generate Project Metrics
        run: |
          # Create metrics.json if analyze_project.py doesn't exist
          if [ -f scripts/analyze_project.py ]; then
            python scripts/analyze_project.py --output=metrics.json
          else
            echo '{"status":"pending","message":"analyze_project.py not implemented"}' > metrics.json
          fi
        continue-on-error: true
      - name: Update PROJECT_STATUS.md
        run: |
          # Create update_status.py if it doesn't exist
          if [ -f .github/scripts/update_status.py ]; then
            python .github/scripts/update_status.py
          else
            echo "⚠️  update_status.py not implemented - skipping"
          fi
        continue-on-error: true
      - name: Auto-Commit If Changed
        if: inputs.commit_changes || github.event_name == 'schedule'
        run: |
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'
          git add PROJECT_STATUS.md metrics.json || true
          git diff --staged --quiet || git commit -m "chore: update project status from health check [skip ci]"
          git push || echo "No changes to push"
      - name: Create Weekly Health Report Issue
        if: github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueTitle = `📊 Weekly Project Health Report - ${new Date().toISOString().split('T')[0]}`;
            
            // Read metrics
            let metrics = {};
            try {
              metrics = JSON.parse(fs.readFileSync('metrics.json', 'utf8'));
            } catch (e) {
              metrics = {status: 'error', message: 'Could not read metrics'};
            }
            
            // Create issue body
            const body = `## Weekly Health Check Results
            
            **Generated:** ${new Date().toISOString()}
            
            ### Metrics
            \`\`\`json
            ${JSON.stringify(metrics, null, 2)}
            \`\`\`
            
            ### Artifacts
            - Test coverage reports
            - Security scan results
            - Lint reports
            
            **Action:** Review attached artifacts for details.
            `;
            
            // Search for existing open health report issues
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check',
              per_page: 100
            });
            
            // Close old health check issues (keep only latest)
            for (const issue of existingIssues.data) {
              if (issue.title.startsWith('📊 Weekly Project Health Report')) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
            }
            
            // Create new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: body,
              labels: ['health-check', '📊 monitoring']
            });
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: health-reports-${{ github.run_number }}
          path: |
            *.json
            mypy-report/
            *.txt
          retention-days: 30

  project-sync-and-manage:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: contains(fromJSON('["issues", "pull_request_target"]'), github.event_name) || (github.event_name == 'workflow_dispatch' && (inputs.sync_existing || inputs.action == 'sync-all-issues' || inputs.action == 'cleanup-stale-items'))
    steps:
      - uses: actions/checkout@v4
      - name: Add to Project
        uses: actions/add-to-project@v1.0.2
        with:
          project-url: https://github.com/users/${{ github.repository_owner }}/projects/${{ env.PROJECT_NUMBER }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Sync Project Items
        if: inputs.sync_existing || inputs.action == 'sync-all-issues'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('🔄 Syncing all issues and PRs to project board...');
            
            // Get all open issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${issues.data.length} open issues/PRs`);
            
            // Note: Full project board sync requires GraphQL API
            // This is a placeholder - implement when needed
            // For now, the add-to-project action above handles new items
      - name: Cleanup Stale Items
        if: inputs.action == 'cleanup-stale-items'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('🧹 Cleaning up stale project items...');
            
            // Get all closed issues older than 30 days
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const closedIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });
            
            console.log(`Found ${closedIssues.data.length} recently closed issues`);
            
            // Archive closed items from project (requires GraphQL)
            // Placeholder for now

  create-phased-issues:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'issues' && github.event.action == 'opened' && contains(github.event.issue.labels.*.name, 'phased-implementation')
    steps:
      - uses: actions/checkout@v4
      - name: Get Issue Details and Create Phases
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            console.log(`🔨 Creating phased issues for #${issue.number}: ${issue.title}`);
            
            // Check if issue has phased-implementation label
            const hasLabel = issue.labels.some(label => label.name === 'phased-implementation');
            if (!hasLabel) {
              console.log('Issue does not have phased-implementation label, skipping');
              return;
            }
            
            // Parse issue body for phases
            // Expected format:
            // ## Phase 1: Title
            // - Task 1
            // - Task 2
            //
            // ## Phase 2: Title
            // - Task 1
            
            const phaseRegex = /## Phase (\d+): (.+?)\n([\s\S]*?)(?=## Phase|\n*$)/g;
            const phases = [];
            let match;
            
            while ((match = phaseRegex.exec(issue.body)) !== null) {
              phases.push({
                number: parseInt(match[1]),
                title: match[2].trim(),
                tasks: match[3].trim()
              });
            }
            
            console.log(`Found ${phases.length} phases to create`);
            
            // Create issues for each phase
            for (const phase of phases) {
              const phaseTitle = `[Phase ${phase.number}] ${phase.title}`;
              const phaseBody = `**Parent Issue:** #${issue.number}
            
            ${phase.tasks}
            
            ---
            *Auto-generated from phased implementation issue*`;
              
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: phaseTitle,
                body: phaseBody,
                labels: ['phase', ...(issue.labels.map(l => l.name).filter(n => n !== 'phased-implementation'))]
              });
              
              console.log(`Created issue #${newIssue.data.number}: ${phaseTitle}`);
              
              // Comment on parent issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `Created Phase ${phase.number} issue: #${newIssue.data.number}`
              });
            }

  notify-complete:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [notify-start, label-pr, test, lint, security, docker-build-push, release, dns-update, health-check, project-sync-and-manage, create-phased-issues]
    if: ${{ !cancelled() }}
    steps:
      - name: Determine Overall Status
        id: status
        run: |
          # Check if security (critical) failed - tests/lint allowed to fail temporarily
          if [[ "${{ needs.security.result }}" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "color=16711680" >> $GITHUB_OUTPUT  # Red
            echo "message=Critical security issues found" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.test.result }}" == "success" ]] && \
               [[ "${{ needs.lint.result }}" == "success" ]] && \
               [[ "${{ needs.security.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "color=65280" >> $GITHUB_OUTPUT  # Green
            echo "message=All checks passed" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "color=16753920" >> $GITHUB_OUTPUT  # Orange
            echo "message=Some non-critical checks failed (expected until Phase 1 complete)" >> $GITHUB_OUTPUT
          fi
      - name: Send Discord Complete Notification
        uses: sarisia/actions-status-discord@v1
        if: always()
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK }}
          title: "${{ steps.status.outputs.status == 'success' && '✅' || steps.status.outputs.status == 'failure' && '❌' || '⚠️' }} Pipeline Complete"
          description: |
            **Overall Status:** ${{ steps.status.outputs.status }}
            **Message:** ${{ steps.status.outputs.message }}
            **Event:** ${{ github.event_name }}
            **Branch:** ${{ github.ref_name }}
            **Commit:** `${{ github.sha }}`
            
            **Job Results:**
            - Test: ${{ needs.test.result || 'skipped' }} (expected failures until #75)
            - Lint: ${{ needs.lint.result || 'skipped' }} (expected failures until #76)
            - Security: ${{ needs.security.result || 'skipped' }} ⚠️ CRITICAL
            - Docker: ${{ needs.docker-build-push.result || 'skipped' }}
            - Release: ${{ needs.release.result || 'skipped' }}
            
            **Note:** Test/lint failures are expected during Phase 1 development
          color: ${{ steps.status.outputs.color }}
          username: FKS Bot