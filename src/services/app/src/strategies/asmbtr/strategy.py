"""ASMBTR Event-Driven Trading Strategy.

This module implements the complete ASMBTR (Adaptive State Model on Binary
Tree Representation) trading strategy with entry/exit logic, position sizing,
and risk management.

Phase: AI Enhancement Plan - Phase 2
Target: Calmar ratio >0.3 on backtests
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from enum import Enum
import logging

from .btr import BTRState
from .encoder import StateEncoder
from .predictor import PredictionTable, StatePrediction

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


@dataclass
class TradingSignal:
    """Trading signal generated by ASMBTR strategy.
    
    Attributes:
        signal_type: BUY, SELL, or HOLD
        state: BTR state that generated the signal
        prediction: Prediction from table
        confidence: Signal confidence (0.0-1.0)
        timestamp: When signal was generated
        price: Price at signal generation
    """
    signal_type: SignalType
    state: BTRState
    prediction: Optional[StatePrediction]
    confidence: float
    timestamp: datetime
    price: Decimal
    
    def __str__(self) -> str:
        return (f"Signal({self.signal_type.value}, "
                f"state={self.state.sequence}, "
                f"confidence={self.confidence:.3f}, "
                f"price={self.price})")


@dataclass
class Position:
    """Represents an open trading position.
    
    Attributes:
        entry_price: Price at position entry
        entry_time: When position was opened
        size: Position size (in base currency)
        side: "LONG" or "SHORT"
        stop_loss: Stop loss price
        take_profit: Take profit price
    """
    entry_price: Decimal
    entry_time: datetime
    size: Decimal
    side: str  # "LONG" or "SHORT"
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    
    def get_pnl(self, current_price: Decimal) -> Decimal:
        """Calculate current PnL.
        
        Args:
            current_price: Current market price
        
        Returns:
            PnL in base currency
        """
        if self.side == "LONG":
            return (current_price - self.entry_price) * self.size
        else:  # SHORT
            return (self.entry_price - current_price) * self.size
    
    def get_pnl_percent(self, current_price: Decimal) -> float:
        """Calculate current PnL as percentage.
        
        Args:
            current_price: Current market price
        
        Returns:
            PnL percentage
        """
        pnl = self.get_pnl(current_price)
        return float((pnl / (self.entry_price * self.size)) * 100)


@dataclass
class StrategyConfig:
    """Configuration for ASMBTR strategy.
    
    Attributes:
        depth: BTR encoding depth
        confidence_threshold: Minimum confidence to trade (0.0-1.0)
        min_observations: Minimum observations required for prediction
        position_size_pct: Position size as % of capital (0.0-1.0)
        stop_loss_pct: Stop loss as % from entry (0.0-1.0)
        take_profit_pct: Take profit as % from entry (0.0-1.0)
        decay_rate: Decay rate for prediction table (0.9-1.0)
    """
    depth: int = 8
    confidence_threshold: float = 0.1  # Low threshold for baseline
    min_observations: int = 5
    position_size_pct: float = 0.02  # 2% of capital per trade
    stop_loss_pct: float = 0.005  # 0.5% stop loss
    take_profit_pct: float = 0.010  # 1% take profit
    decay_rate: float = 0.999  # Slow decay


@dataclass
class StrategyMetrics:
    """Performance metrics for ASMBTR strategy.
    
    Attributes:
        total_trades: Total number of trades
        winning_trades: Number of winning trades
        losing_trades: Number of losing trades
        total_pnl: Total profit/loss
        max_drawdown: Maximum drawdown observed
        sharpe_ratio: Sharpe ratio
        calmar_ratio: Calmar ratio (target: >0.3)
    """
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: Decimal = Decimal("0")
    max_drawdown: Decimal = Decimal("0")
    peak_equity: Decimal = Decimal("0")
    sharpe_ratio: float = 0.0
    calmar_ratio: float = 0.0
    
    @property
    def win_rate(self) -> float:
        """Calculate win rate.
        
        Returns:
            Win rate as percentage (0-100)
        """
        if self.total_trades == 0:
            return 0.0
        return (self.winning_trades / self.total_trades) * 100
    
    def update(self, trade_pnl: Decimal, current_equity: Decimal) -> None:
        """Update metrics with new trade result.
        
        Args:
            trade_pnl: PnL from closed trade
            current_equity: Current equity after trade
        """
        self.total_trades += 1
        self.total_pnl += trade_pnl
        
        if trade_pnl > 0:
            self.winning_trades += 1
        else:
            self.losing_trades += 1
        
        # Update drawdown
        if current_equity > self.peak_equity:
            self.peak_equity = current_equity
        
        drawdown = self.peak_equity - current_equity
        if drawdown > self.max_drawdown:
            self.max_drawdown = drawdown


class ASMBTRStrategy:
    """ASMBTR trading strategy implementation.
    
    This strategy uses BTR state prediction to generate trading signals
    with adaptive position sizing and risk management.
    
    Attributes:
        config: Strategy configuration
        encoder: State encoder
        prediction_table: Prediction table
        current_position: Current open position (if any)
        initial_capital: Starting capital
        current_capital: Current capital
        metrics: Performance metrics
    """
    
    def __init__(
        self,
        config: Optional[StrategyConfig] = None,
        initial_capital: Decimal = Decimal("10000")
    ):
        """Initialize ASMBTR strategy.
        
        Args:
            config: Strategy configuration (uses defaults if None)
            initial_capital: Starting capital
        """
        self.config = config or StrategyConfig()
        self.encoder = StateEncoder(depth=self.config.depth)
        self.prediction_table = PredictionTable(
            depth=self.config.depth,
            decay_rate=self.config.decay_rate
        )
        
        self.current_position: Optional[Position] = None
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.metrics = StrategyMetrics(peak_equity=initial_capital)
        
        self.trade_history: List[Dict[str, Any]] = []
        
        logger.info(f"ASMBTRStrategy initialized: "
                   f"depth={self.config.depth}, "
                   f"capital={initial_capital}")
    
    def process_tick(
        self,
        tick: Dict[str, Any],
        price_key: str = 'last'
    ) -> Optional[TradingSignal]:
        """Process a tick and generate trading signal.
        
        Args:
            tick: Tick dictionary with price data
            price_key: Key to extract price from tick
        
        Returns:
            TradingSignal or None
        """
        # Encode tick to BTR state
        state = self.encoder.process_tick(tick, price_key=price_key)
        
        if not state:
            return None  # Not enough data yet
        
        # Get prediction
        prediction = self.prediction_table.predict(
            state,
            min_observations=self.config.min_observations
        )
        
        if not prediction:
            return TradingSignal(
                signal_type=SignalType.HOLD,
                state=state,
                prediction=None,
                confidence=0.0,
                timestamp=tick.get('timestamp', datetime.now()),
                price=tick[price_key]
            )
        
        # Generate signal based on prediction
        signal_type = self._generate_signal(prediction)
        
        return TradingSignal(
            signal_type=signal_type,
            state=state,
            prediction=prediction,
            confidence=prediction.confidence,
            timestamp=tick.get('timestamp', datetime.now()),
            price=tick[price_key]
        )
    
    def _generate_signal(self, prediction: StatePrediction) -> SignalType:
        """Generate trading signal from prediction.
        
        Args:
            prediction: State prediction
        
        Returns:
            SignalType (BUY, SELL, or HOLD)
        """
        # Check confidence threshold
        if prediction.confidence < self.config.confidence_threshold:
            return SignalType.HOLD
        
        # Generate signal based on prediction
        if prediction.prediction == "UP" and not self.current_position:
            return SignalType.BUY
        elif prediction.prediction == "DOWN" and self.current_position:
            return SignalType.SELL
        
        return SignalType.HOLD
    
    def execute_signal(self, signal: TradingSignal) -> Optional[Position]:
        """Execute a trading signal.
        
        Args:
            signal: Trading signal to execute
        
        Returns:
            New Position if opened, or None
        """
        if signal.signal_type == SignalType.BUY and not self.current_position:
            return self._open_long(signal)
        
        elif signal.signal_type == SignalType.SELL and self.current_position:
            return self._close_position(signal)
        
        return None
    
    def _open_long(self, signal: TradingSignal) -> Position:
        """Open a long position.
        
        Args:
            signal: BUY signal
        
        Returns:
            Opened Position
        """
        position_value = self.current_capital * Decimal(str(self.config.position_size_pct))
        size = position_value / signal.price
        
        stop_loss = signal.price * (1 - Decimal(str(self.config.stop_loss_pct)))
        take_profit = signal.price * (1 + Decimal(str(self.config.take_profit_pct)))
        
        position = Position(
            entry_price=signal.price,
            entry_time=signal.timestamp,
            size=size,
            side="LONG",
            stop_loss=stop_loss,
            take_profit=take_profit
        )
        
        self.current_position = position
        
        logger.info(f"📈 LONG opened: price={signal.price}, "
                   f"size={size:.4f}, "
                   f"SL={stop_loss}, TP={take_profit}")
        
        return position
    
    def _close_position(self, signal: TradingSignal) -> None:
        """Close current position.
        
        Args:
            signal: SELL signal
        """
        if not self.current_position:
            return
        
        pnl = self.current_position.get_pnl(signal.price)
        self.current_capital += pnl
        
        # Record trade
        trade = {
            'entry_price': float(self.current_position.entry_price),
            'exit_price': float(signal.price),
            'entry_time': self.current_position.entry_time,
            'exit_time': signal.timestamp,
            'side': self.current_position.side,
            'size': float(self.current_position.size),
            'pnl': float(pnl),
            'pnl_pct': self.current_position.get_pnl_percent(signal.price)
        }
        self.trade_history.append(trade)
        
        # Update metrics
        self.metrics.update(pnl, self.current_capital)
        
        logger.info(f"📉 Position closed: PnL={pnl:.2f} "
                   f"({trade['pnl_pct']:.2f}%), "
                   f"Capital={self.current_capital:.2f}")
        
        self.current_position = None
    
    def check_stop_loss_take_profit(self, current_price: Decimal) -> bool:
        """Check if SL or TP is hit.
        
        Args:
            current_price: Current market price
        
        Returns:
            True if position was closed
        """
        if not self.current_position:
            return False
        
        # Check stop loss
        if (self.current_position.stop_loss and 
            current_price <= self.current_position.stop_loss):
            
            logger.info(f"🛑 Stop Loss hit: {current_price} <= {self.current_position.stop_loss}")
            self._close_position(TradingSignal(
                signal_type=SignalType.SELL,
                state=self.encoder.get_current_state(),
                prediction=None,
                confidence=0.0,
                timestamp=datetime.now(),
                price=current_price
            ))
            return True
        
        # Check take profit
        if (self.current_position.take_profit and 
            current_price >= self.current_position.take_profit):
            
            logger.info(f"🎯 Take Profit hit: {current_price} >= {self.current_position.take_profit}")
            self._close_position(TradingSignal(
                signal_type=SignalType.SELL,
                state=self.encoder.get_current_state(),
                prediction=None,
                confidence=1.0,
                timestamp=datetime.now(),
                price=current_price
            ))
            return True
        
        return False
    
    def train_on_history(self, ticks: List[Dict[str, Any]], price_key: str = 'last') -> None:
        """Train prediction table on historical data.
        
        Args:
            ticks: Historical tick data
            price_key: Key to extract price from ticks
        """
        logger.info(f"Training on {len(ticks)} historical ticks...")
        
        from .encoder import StateEncoder
        from .btr import BTRState
        
        # Temporary encoder for training
        train_encoder = StateEncoder(depth=self.config.depth)
        observations = []
        
        for i, tick in enumerate(ticks[:-1]):  # Exclude last tick
            state = train_encoder.process_tick(tick, price_key=price_key)
            
            if state:
                # Get next price
                next_price = ticks[i + 1][price_key]
                current_price = tick[price_key]
                
                if not isinstance(next_price, Decimal):
                    next_price = Decimal(str(next_price))
                if not isinstance(current_price, Decimal):
                    current_price = Decimal(str(current_price))
                
                # Record outcome
                next_move_up = next_price > current_price
                observations.append((state, next_move_up))
        
        # Train prediction table
        if observations:
            states, outcomes = zip(*observations)
            self.prediction_table.observe_sequence(list(states), list(outcomes))
            
            logger.info(f"✅ Trained on {len(observations)} state transitions")
            
            # Log statistics
            stats = self.prediction_table.get_statistics()
            logger.info(f"   Coverage: {stats['coverage']}% of possible states")
            logger.info(f"   Avg observations per state: {stats['avg_observations_per_state']}")
    
    def calculate_calmar_ratio(self) -> float:
        """Calculate Calmar ratio.
        
        Returns:
            Calmar ratio (annualized return / max drawdown)
        """
        if self.metrics.max_drawdown == 0:
            return 0.0
        
        total_return = float((self.current_capital - self.initial_capital) / self.initial_capital)
        max_dd_pct = float(self.metrics.max_drawdown / self.initial_capital)
        
        if max_dd_pct == 0:
            return 0.0
        
        calmar = total_return / max_dd_pct
        self.metrics.calmar_ratio = calmar
        
        return calmar
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get comprehensive performance summary.
        
        Returns:
            Dictionary with all performance metrics
        """
        total_return_pct = float((self.current_capital - self.initial_capital) / self.initial_capital * 100)
        calmar = self.calculate_calmar_ratio()
        
        return {
            'initial_capital': float(self.initial_capital),
            'current_capital': float(self.current_capital),
            'total_return': float(self.current_capital - self.initial_capital),
            'total_return_pct': round(total_return_pct, 2),
            'total_trades': self.metrics.total_trades,
            'winning_trades': self.metrics.winning_trades,
            'losing_trades': self.metrics.losing_trades,
            'win_rate': round(self.metrics.win_rate, 2),
            'max_drawdown': float(self.metrics.max_drawdown),
            'max_drawdown_pct': round(float(self.metrics.max_drawdown / self.initial_capital * 100), 2),
            'calmar_ratio': round(calmar, 3),
            'prediction_table_stats': self.prediction_table.get_statistics()
        }


if __name__ == "__main__":
    """Example usage with simulated data."""
    logging.basicConfig(level=logging.INFO)
    
    print("\n" + "="*70)
    print(" ASMBTR Strategy Example ".center(70, "="))
    print("="*70 + "\n")
    
    # Initialize strategy
    config = StrategyConfig(
        depth=8,
        confidence_threshold=0.05,
        position_size_pct=0.02
    )
    strategy = ASMBTRStrategy(config=config, initial_capital=Decimal("10000"))
    
    # Simulate tick data
    import random
    from datetime import timedelta
    
    base_price = Decimal("1.08500")
    ticks = []
    
    print("📊 Generating 500 simulated ticks...")
    for i in range(500):
        # Simulate price movement
        change_pct = random.uniform(-0.0015, 0.0015)
        new_price = base_price * (1 + Decimal(str(change_pct)))
        
        ticks.append({
            'timestamp': datetime.now() + timedelta(seconds=i),
            'symbol': 'EUR/USDT',
            'last': new_price,
            'bid': new_price - Decimal("0.00002"),
            'ask': new_price + Decimal("0.00002")
        })
        
        base_price = new_price
    
    # Train on first 300 ticks
    print("\n🎓 Training on first 300 ticks...")
    strategy.train_on_history(ticks[:300])
    
    # Run strategy on remaining ticks
    print("\n📈 Running strategy on remaining 200 ticks...")
    signals_generated = 0
    
    for tick in ticks[300:]:
        # Generate signal
        signal = strategy.process_tick(tick)
        
        if signal and signal.signal_type != SignalType.HOLD:
            signals_generated += 1
            print(f"  {signal}")
            
            # Execute signal
            strategy.execute_signal(signal)
        
        # Check SL/TP
        if strategy.current_position:
            strategy.check_stop_loss_take_profit(tick['last'])
    
    # Get performance summary
    print(f"\n📊 Performance Summary:")
    summary = strategy.get_performance_summary()
    
    for key, value in summary.items():
        if key != 'prediction_table_stats':
            print(f"  {key}: {value}")
    
    print(f"\n🎯 Calmar Ratio: {summary['calmar_ratio']} (Target: >0.3)")
    
    if summary['calmar_ratio'] > 0.3:
        print("  ✅ Target achieved!")
    else:
        print("  ⚠️ Below target (needs optimization)")
    
    print("\n" + "="*70 + "\n")
